# ESTRUTURA-DE-DADOS

# Marco 1

**Aula 02:[ Atividade 02](Revisao)**

Implemente o TAD PontoCartesiano em Java 

Crie um método construtor;

Getters e Setters;

Crie um método que calcule a distância euclidiana entre dois pontos;

Teste esse TAD em uma classe Main.

**Aula 03:[ Atividade 03](Exercicio_02)**

Criar uma classe Aluno. Sobre um aluno devem ser guardados:

Nome

Idade

Nota

Utilize o TAD Vetor, adaptando-o para armazenar Alunos;

Adapte os métodos “adiciona”, “tamanho” e “contem” para o contexto de Alunos;

**Aula 04:[ Atividade 04](Vetor)**

Adapte o programa exemplificado em aula para um novo programa, incluindo implementações para IVetorAluno,  para um Vetor de Alunos.

Crie uma classe Vetor que permita armazenar qualquer objeto dentro do vetor.

**Aula 05:[ Atividade 05](Atividade_5)**

Implemente um TAD LSE genérica de modo que seja possível inserir Alunos ou quaisquer outros tipos de objetos.

Implemente um método para fazer a impressão da lista.
   
**Aula 06:[ Atividade 6.1](LDE_de_inteiros)**

Implemente um TAD LDE que armazena inteiros;

Em seguida, refatore o método remove() de modo que a busca ocorra em outro método e seu retorno seja utilizado no método remove();

Implemente o método de impressão de modo que seja possível escrever os inteiros em ambos os sentidos;

**Aula 07:[ Atividade 6.2](LDE_Objet)**
 
Implemente um TAD LDE genérica (Object);
      
Em seguida, faça com que ela armazene Alunos;
      
Implemente o método de impressão de modo que seja possível escrever os objetos em ambos os sentidos.

**Aulas 7, 8 e 9: Trabalho Avaliativo I - Locadora de Veículos: [Trabalho01](Trabalho01)**

**Aula 10:[ Atividade 07](Recursividade)**
      
Utilize o TAD Vetor e implemente um método recursivo para encontrar o maior elemento.
      
Implemente um método iterativo para esse fim também.
      
Utilize algum método de cômputo de tempo para registrar o tempo de execução de cada um desses métodos para um vetor com 1000 números inteiros aleatórios.
      
**Aula 11:[ Atividade 08](Busca_linear_e_binaria)**
 
Implementar o método de pesquisa binária com laço de repetição e outro método usando recursão;

Utilize o TAD Vetor armazenando números inteiros;

Gere um vetor aleatório com 1.000 elementos e submeta o mesmo vetor a ambos os métodos, computando o tempo para a pesquisa do último elemento armazenado no vetor.
     
**Aula 12:[ Atividade 9](Ordenacão_Básica)**
 
Implemente os métodos de ordenação discutidos em aula.

Utilize o TAD Vetor armazenando números inteiros;
 
Gere um vetor aleatório com 1.000 elementos e submeta o mesmo vetor aos métodos de ordenação, computando o tempo da execução.
      
**Aula 13 e 14 Prova Prática P1:[ Questao 1](Questao1)**
  
Escreva um programa iterativo (Java) que recebe como entrada dois arranjos (dois vetores de inteiros), cada um com n elementos, e devolve como saída a interseção entre os dois. 
      
**Aula 13 e 14 Prova Prática P1:[ Questao 3](Questao3)**
   
Implemente, em Linguagem Java, um método que calcula o enésimo termo da série de Fibonacci, tendo como base a descrição matemática recursiva a seguirs. 
                   
**Aula 13 e 14 Prova Prática P1:[ Questao 10](Questao10)**
 
Ordene crescentes os elementos do vetor [3, 7, 1, 4, 9, 2], utilizando os seguintes algoritmos de ordenação: Bubble, selection e insertion sort. Mostrar o estado do vetor toda a vez que ocorrer uma troca de elementos
  
**Aula 13 e 14 Prova Prática P1:[ Questao 12](Questao12)**
 
Implemente, em Java, um método recursivo que representa a definição matemática recursiva a seguir. Além disso, responda: a implementação recursiva seria sua primeira opção para resolver o problema do somatório de números inteiros?   
 
# Marco 2

**Aula 15:[ Atividade 10](Filas_vetor)**
 
Implemente os exemplos.

Implemente um método para fazer a impressão da fila.

**Aula 16:[ Atividade 11](Fila_lde)**
 
Implemente os exemplos

Implemente os métodos size() e isEmpty() e armazene alunos na fila.

Implemente um método de impressão para mostrar o estado da fila.

**Aula 17 e 18:[ Trabalho_2](Trabalho_2)**
 
Uma palavra é uma palíndromo se a seqüência de letras que a forma é a mesma seja ela lida da esquerda para a direita ou vice-versa. Exemplos: arara. Escreva um método palíndromo que, dada uma palavra, retorne true caso a palavra seja uma palíndromo, e false caso contrário. Use uma pilha para tal (representada como vetor). Implemente um método de impressão para mostrar o estado da pilha.

Implemente os métodos size() e isEmpty() e top() para uma pilha de alunos. Em seguida, utilize uma fila de alunos com LSE e inverta a ordem dos alunos da fila usando a pilha que você implementou.

Implemente um método de impressão para mostrar o estado da pilha.

**Aula 19:[ Atividade 13](Mapa_Vetor)**

Encontre uma forma de minimizar o problema das colisões procurando pela próxima posição livre. 

Dica 1: endereçamento aberto

Procurar um outro índice livre do vetor para armazenar o elemento quando houver colisão

Dica 2: Vetor cresce dinâmico

Resize() e Rehasing()

**Aula 20:[ Atividade 14](Mapa_lse)**

Implementar os demais métodos remove() e get(), considerando os esquemas de colisão apresentados.

Implemente o mecanismo de resize() e rehash().

Faça testes criando funções de impressão do mapa.

Adapte o código para o T2.

# Marco 2

**Aula 21:[ Atividade 15](Arvore)**

Implementar o TAD ABB;

Implementar o método de busca;

Implementar o método de impressão (percorrer a árvore);

**Aula 21:[ Atividade 16](Remocao_Arvore)**

Implementar o TAD ABB;

Implementar os métodos de busca apresentados;

Implementar os métodos de impressão;

Implementar o método de remoção de nós, pensando nos três casos;
